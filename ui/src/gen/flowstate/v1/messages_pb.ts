// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file flowstate/v1/messages.proto (package flowstate.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";

/**
 * @generated from message flowstate.v1.State
 */
export class State extends Message<State> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: int64 rev = 2;
   */
  rev = protoInt64.zero;

  /**
   * @generated from field: map<string, string> annotations = 3;
   */
  annotations: { [key: string]: string } = {};

  /**
   * @generated from field: map<string, string> labels = 4;
   */
  labels: { [key: string]: string } = {};

  /**
   * @generated from field: int64 committed_at_unix_milli = 5;
   */
  committedAtUnixMilli = protoInt64.zero;

  /**
   * @generated from field: flowstate.v1.Transition transition = 6;
   */
  transition?: Transition;

  constructor(data?: PartialMessage<State>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flowstate.v1.State";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "rev", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "annotations", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 4, name: "labels", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 5, name: "committed_at_unix_milli", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 6, name: "transition", kind: "message", T: Transition },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): State {
    return new State().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): State {
    return new State().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): State {
    return new State().fromJsonString(jsonString, options);
  }

  static equals(a: State | PlainMessage<State> | undefined, b: State | PlainMessage<State> | undefined): boolean {
    return proto3.util.equals(State, a, b);
  }
}

/**
 * @generated from message flowstate.v1.StateCtx
 */
export class StateCtx extends Message<StateCtx> {
  /**
   * @generated from field: flowstate.v1.State committed = 1;
   */
  committed?: State;

  /**
   * @generated from field: flowstate.v1.State current = 2;
   */
  current?: State;

  /**
   * @generated from field: repeated flowstate.v1.Transition transitions = 3;
   */
  transitions: Transition[] = [];

  /**
   * @generated from field: map<string, flowstate.v1.Data> datas = 4;
   */
  datas: { [key: string]: Data } = {};

  constructor(data?: PartialMessage<StateCtx>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flowstate.v1.StateCtx";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "committed", kind: "message", T: State },
    { no: 2, name: "current", kind: "message", T: State },
    { no: 3, name: "transitions", kind: "message", T: Transition, repeated: true },
    { no: 4, name: "datas", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Data} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StateCtx {
    return new StateCtx().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StateCtx {
    return new StateCtx().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StateCtx {
    return new StateCtx().fromJsonString(jsonString, options);
  }

  static equals(a: StateCtx | PlainMessage<StateCtx> | undefined, b: StateCtx | PlainMessage<StateCtx> | undefined): boolean {
    return proto3.util.equals(StateCtx, a, b);
  }
}

/**
 * @generated from message flowstate.v1.StateCtxRef
 */
export class StateCtxRef extends Message<StateCtxRef> {
  /**
   * @generated from field: int64 idx = 1;
   */
  idx = protoInt64.zero;

  constructor(data?: PartialMessage<StateCtxRef>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flowstate.v1.StateCtxRef";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "idx", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StateCtxRef {
    return new StateCtxRef().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StateCtxRef {
    return new StateCtxRef().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StateCtxRef {
    return new StateCtxRef().fromJsonString(jsonString, options);
  }

  static equals(a: StateCtxRef | PlainMessage<StateCtxRef> | undefined, b: StateCtxRef | PlainMessage<StateCtxRef> | undefined): boolean {
    return proto3.util.equals(StateCtxRef, a, b);
  }
}

/**
 * @generated from message flowstate.v1.DelayedState
 */
export class DelayedState extends Message<DelayedState> {
  /**
   * @generated from field: flowstate.v1.State state = 1;
   */
  state?: State;

  /**
   * @generated from field: int64 offset = 2;
   */
  offset = protoInt64.zero;

  /**
   * @generated from field: int64 execute_at_sec = 3;
   */
  executeAtSec = protoInt64.zero;

  constructor(data?: PartialMessage<DelayedState>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flowstate.v1.DelayedState";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "state", kind: "message", T: State },
    { no: 2, name: "offset", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "execute_at_sec", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DelayedState {
    return new DelayedState().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DelayedState {
    return new DelayedState().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DelayedState {
    return new DelayedState().fromJsonString(jsonString, options);
  }

  static equals(a: DelayedState | PlainMessage<DelayedState> | undefined, b: DelayedState | PlainMessage<DelayedState> | undefined): boolean {
    return proto3.util.equals(DelayedState, a, b);
  }
}

/**
 * @generated from message flowstate.v1.Transition
 */
export class Transition extends Message<Transition> {
  /**
   * @generated from field: string from = 1;
   */
  from = "";

  /**
   * @generated from field: string to = 2;
   */
  to = "";

  /**
   * @generated from field: map<string, string> annotations = 3;
   */
  annotations: { [key: string]: string } = {};

  constructor(data?: PartialMessage<Transition>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flowstate.v1.Transition";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "from", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "to", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "annotations", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Transition {
    return new Transition().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Transition {
    return new Transition().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Transition {
    return new Transition().fromJsonString(jsonString, options);
  }

  static equals(a: Transition | PlainMessage<Transition> | undefined, b: Transition | PlainMessage<Transition> | undefined): boolean {
    return proto3.util.equals(Transition, a, b);
  }
}

/**
 * @generated from message flowstate.v1.Data
 */
export class Data extends Message<Data> {
  /**
   * @generated from field: int64 rev = 2;
   */
  rev = protoInt64.zero;

  /**
   * @generated from field: string blob = 4;
   */
  blob = "";

  /**
   * @generated from field: map<string, string> annotations = 5;
   */
  annotations: { [key: string]: string } = {};

  constructor(data?: PartialMessage<Data>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flowstate.v1.Data";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "rev", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "blob", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "annotations", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Data {
    return new Data().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Data {
    return new Data().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Data {
    return new Data().fromJsonString(jsonString, options);
  }

  static equals(a: Data | PlainMessage<Data> | undefined, b: Data | PlainMessage<Data> | undefined): boolean {
    return proto3.util.equals(Data, a, b);
  }
}

/**
 * @generated from message flowstate.v1.Command
 */
export class Command extends Message<Command> {
  /**
   * @generated from field: repeated flowstate.v1.StateCtx state_ctxs = 1;
   */
  stateCtxs: StateCtx[] = [];

  /**
   * @generated from field: flowstate.v1.TransitCommand transit = 3;
   */
  transit?: TransitCommand;

  /**
   * @generated from field: flowstate.v1.ParkCommand park = 6;
   */
  park?: ParkCommand;

  /**
   * @generated from field: flowstate.v1.ExecuteCommand execute = 7;
   */
  execute?: ExecuteCommand;

  /**
   * @generated from field: flowstate.v1.DelayCommand delay = 8;
   */
  delay?: DelayCommand;

  /**
   * @generated from field: flowstate.v1.CommitCommand commit = 9;
   */
  commit?: CommitCommand;

  /**
   * @generated from field: flowstate.v1.NoopCommand noop = 10;
   */
  noop?: NoopCommand;

  /**
   * @generated from field: flowstate.v1.StackCommand stack = 11;
   */
  stack?: StackCommand;

  /**
   * @generated from field: flowstate.v1.UnstackCommand unstack = 12;
   */
  unstack?: UnstackCommand;

  /**
   * @generated from field: flowstate.v1.GetStateByIDCommand get_state_by_id = 17;
   */
  getStateById?: GetStateByIDCommand;

  /**
   * @generated from field: flowstate.v1.GetStateByLabelsCommand get_state_by_labels = 18;
   */
  getStateByLabels?: GetStateByLabelsCommand;

  /**
   * @generated from field: flowstate.v1.GetStatesCommand get_states = 19;
   */
  getStates?: GetStatesCommand;

  /**
   * @generated from field: flowstate.v1.GetDelayedStatesCommand get_delayed_states = 20;
   */
  getDelayedStates?: GetDelayedStatesCommand;

  /**
   * @generated from field: flowstate.v1.StoreDataCommand store_data = 21;
   */
  storeData?: StoreDataCommand;

  /**
   * @generated from field: flowstate.v1.GetDataCommand get_data = 22;
   */
  getData?: GetDataCommand;

  constructor(data?: PartialMessage<Command>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flowstate.v1.Command";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "state_ctxs", kind: "message", T: StateCtx, repeated: true },
    { no: 3, name: "transit", kind: "message", T: TransitCommand },
    { no: 6, name: "park", kind: "message", T: ParkCommand },
    { no: 7, name: "execute", kind: "message", T: ExecuteCommand },
    { no: 8, name: "delay", kind: "message", T: DelayCommand },
    { no: 9, name: "commit", kind: "message", T: CommitCommand },
    { no: 10, name: "noop", kind: "message", T: NoopCommand },
    { no: 11, name: "stack", kind: "message", T: StackCommand },
    { no: 12, name: "unstack", kind: "message", T: UnstackCommand },
    { no: 17, name: "get_state_by_id", kind: "message", T: GetStateByIDCommand },
    { no: 18, name: "get_state_by_labels", kind: "message", T: GetStateByLabelsCommand },
    { no: 19, name: "get_states", kind: "message", T: GetStatesCommand },
    { no: 20, name: "get_delayed_states", kind: "message", T: GetDelayedStatesCommand },
    { no: 21, name: "store_data", kind: "message", T: StoreDataCommand },
    { no: 22, name: "get_data", kind: "message", T: GetDataCommand },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Command {
    return new Command().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Command {
    return new Command().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Command {
    return new Command().fromJsonString(jsonString, options);
  }

  static equals(a: Command | PlainMessage<Command> | undefined, b: Command | PlainMessage<Command> | undefined): boolean {
    return proto3.util.equals(Command, a, b);
  }
}

/**
 * @generated from message flowstate.v1.TransitCommand
 */
export class TransitCommand extends Message<TransitCommand> {
  /**
   * State to transit, required
   *
   * @generated from field: flowstate.v1.StateCtxRef state_ref = 1;
   */
  stateRef?: StateCtxRef;

  /**
   * @generated from field: string to = 2;
   */
  to = "";

  /**
   * Transition annotations, optional
   *
   * @generated from field: map<string, string> annotations = 3;
   */
  annotations: { [key: string]: string } = {};

  constructor(data?: PartialMessage<TransitCommand>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flowstate.v1.TransitCommand";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "state_ref", kind: "message", T: StateCtxRef },
    { no: 2, name: "to", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "annotations", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TransitCommand {
    return new TransitCommand().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TransitCommand {
    return new TransitCommand().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TransitCommand {
    return new TransitCommand().fromJsonString(jsonString, options);
  }

  static equals(a: TransitCommand | PlainMessage<TransitCommand> | undefined, b: TransitCommand | PlainMessage<TransitCommand> | undefined): boolean {
    return proto3.util.equals(TransitCommand, a, b);
  }
}

/**
 * @generated from message flowstate.v1.ParkCommand
 */
export class ParkCommand extends Message<ParkCommand> {
  /**
   * State to park, required
   *
   * @generated from field: flowstate.v1.StateCtxRef state_rexf = 1;
   */
  stateRexf?: StateCtxRef;

  /**
   * Transition annotations, optional
   *
   * @generated from field: map<string, string> annotations = 3;
   */
  annotations: { [key: string]: string } = {};

  constructor(data?: PartialMessage<ParkCommand>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flowstate.v1.ParkCommand";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "state_rexf", kind: "message", T: StateCtxRef },
    { no: 3, name: "annotations", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ParkCommand {
    return new ParkCommand().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ParkCommand {
    return new ParkCommand().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ParkCommand {
    return new ParkCommand().fromJsonString(jsonString, options);
  }

  static equals(a: ParkCommand | PlainMessage<ParkCommand> | undefined, b: ParkCommand | PlainMessage<ParkCommand> | undefined): boolean {
    return proto3.util.equals(ParkCommand, a, b);
  }
}

/**
 * @generated from message flowstate.v1.ExecuteCommand
 */
export class ExecuteCommand extends Message<ExecuteCommand> {
  /**
   * @generated from field: flowstate.v1.StateCtxRef state_ref = 1;
   */
  stateRef?: StateCtxRef;

  constructor(data?: PartialMessage<ExecuteCommand>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flowstate.v1.ExecuteCommand";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "state_ref", kind: "message", T: StateCtxRef },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExecuteCommand {
    return new ExecuteCommand().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExecuteCommand {
    return new ExecuteCommand().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExecuteCommand {
    return new ExecuteCommand().fromJsonString(jsonString, options);
  }

  static equals(a: ExecuteCommand | PlainMessage<ExecuteCommand> | undefined, b: ExecuteCommand | PlainMessage<ExecuteCommand> | undefined): boolean {
    return proto3.util.equals(ExecuteCommand, a, b);
  }
}

/**
 * @generated from message flowstate.v1.DelayCommand
 */
export class DelayCommand extends Message<DelayCommand> {
  /**
   * @generated from field: flowstate.v1.StateCtxRef state_ref = 1;
   */
  stateRef?: StateCtxRef;

  /**
   * @generated from field: int64 execute_at_sec = 3;
   */
  executeAtSec = protoInt64.zero;

  /**
   * @generated from field: bool commit = 4;
   */
  commit = false;

  /**
   * @generated from field: string to = 5;
   */
  to = "";

  /**
   * Transition annotations, optional
   *
   * @generated from field: map<string, string> annotations = 6;
   */
  annotations: { [key: string]: string } = {};

  /**
   * Result of successful delay command execution
   *
   * @generated from field: flowstate.v1.DelayedState result = 2;
   */
  result?: DelayedState;

  constructor(data?: PartialMessage<DelayCommand>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flowstate.v1.DelayCommand";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "state_ref", kind: "message", T: StateCtxRef },
    { no: 3, name: "execute_at_sec", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "commit", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "to", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "annotations", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 2, name: "result", kind: "message", T: DelayedState },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DelayCommand {
    return new DelayCommand().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DelayCommand {
    return new DelayCommand().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DelayCommand {
    return new DelayCommand().fromJsonString(jsonString, options);
  }

  static equals(a: DelayCommand | PlainMessage<DelayCommand> | undefined, b: DelayCommand | PlainMessage<DelayCommand> | undefined): boolean {
    return proto3.util.equals(DelayCommand, a, b);
  }
}

/**
 * @generated from message flowstate.v1.CommitCommand
 */
export class CommitCommand extends Message<CommitCommand> {
  /**
   * @generated from field: repeated flowstate.v1.Command commands = 1;
   */
  commands: Command[] = [];

  constructor(data?: PartialMessage<CommitCommand>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flowstate.v1.CommitCommand";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "commands", kind: "message", T: Command, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CommitCommand {
    return new CommitCommand().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CommitCommand {
    return new CommitCommand().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CommitCommand {
    return new CommitCommand().fromJsonString(jsonString, options);
  }

  static equals(a: CommitCommand | PlainMessage<CommitCommand> | undefined, b: CommitCommand | PlainMessage<CommitCommand> | undefined): boolean {
    return proto3.util.equals(CommitCommand, a, b);
  }
}

/**
 * @generated from message flowstate.v1.NoopCommand
 */
export class NoopCommand extends Message<NoopCommand> {
  constructor(data?: PartialMessage<NoopCommand>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flowstate.v1.NoopCommand";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NoopCommand {
    return new NoopCommand().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NoopCommand {
    return new NoopCommand().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NoopCommand {
    return new NoopCommand().fromJsonString(jsonString, options);
  }

  static equals(a: NoopCommand | PlainMessage<NoopCommand> | undefined, b: NoopCommand | PlainMessage<NoopCommand> | undefined): boolean {
    return proto3.util.equals(NoopCommand, a, b);
  }
}

/**
 * @generated from message flowstate.v1.StackCommand
 */
export class StackCommand extends Message<StackCommand> {
  /**
   * @generated from field: flowstate.v1.StateCtxRef carrier_state_ref = 1;
   */
  carrierStateRef?: StateCtxRef;

  /**
   * @generated from field: flowstate.v1.StateCtxRef stack_state_ref = 2;
   */
  stackStateRef?: StateCtxRef;

  /**
   * @generated from field: string annotation = 3;
   */
  annotation = "";

  constructor(data?: PartialMessage<StackCommand>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flowstate.v1.StackCommand";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "carrier_state_ref", kind: "message", T: StateCtxRef },
    { no: 2, name: "stack_state_ref", kind: "message", T: StateCtxRef },
    { no: 3, name: "annotation", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StackCommand {
    return new StackCommand().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StackCommand {
    return new StackCommand().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StackCommand {
    return new StackCommand().fromJsonString(jsonString, options);
  }

  static equals(a: StackCommand | PlainMessage<StackCommand> | undefined, b: StackCommand | PlainMessage<StackCommand> | undefined): boolean {
    return proto3.util.equals(StackCommand, a, b);
  }
}

/**
 * @generated from message flowstate.v1.UnstackCommand
 */
export class UnstackCommand extends Message<UnstackCommand> {
  /**
   * @generated from field: flowstate.v1.StateCtxRef carrier_state_ref = 1;
   */
  carrierStateRef?: StateCtxRef;

  /**
   * @generated from field: flowstate.v1.StateCtxRef unstack_state_ref = 2;
   */
  unstackStateRef?: StateCtxRef;

  /**
   * @generated from field: string annotation = 3;
   */
  annotation = "";

  constructor(data?: PartialMessage<UnstackCommand>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flowstate.v1.UnstackCommand";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "carrier_state_ref", kind: "message", T: StateCtxRef },
    { no: 2, name: "unstack_state_ref", kind: "message", T: StateCtxRef },
    { no: 3, name: "annotation", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UnstackCommand {
    return new UnstackCommand().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UnstackCommand {
    return new UnstackCommand().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UnstackCommand {
    return new UnstackCommand().fromJsonString(jsonString, options);
  }

  static equals(a: UnstackCommand | PlainMessage<UnstackCommand> | undefined, b: UnstackCommand | PlainMessage<UnstackCommand> | undefined): boolean {
    return proto3.util.equals(UnstackCommand, a, b);
  }
}

/**
 * @generated from message flowstate.v1.StoreDataCommand
 */
export class StoreDataCommand extends Message<StoreDataCommand> {
  /**
   * @generated from field: flowstate.v1.StateCtxRef state_ref = 1;
   */
  stateRef?: StateCtxRef;

  /**
   * @generated from field: string alias = 2;
   */
  alias = "";

  constructor(data?: PartialMessage<StoreDataCommand>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flowstate.v1.StoreDataCommand";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "state_ref", kind: "message", T: StateCtxRef },
    { no: 2, name: "alias", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StoreDataCommand {
    return new StoreDataCommand().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StoreDataCommand {
    return new StoreDataCommand().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StoreDataCommand {
    return new StoreDataCommand().fromJsonString(jsonString, options);
  }

  static equals(a: StoreDataCommand | PlainMessage<StoreDataCommand> | undefined, b: StoreDataCommand | PlainMessage<StoreDataCommand> | undefined): boolean {
    return proto3.util.equals(StoreDataCommand, a, b);
  }
}

/**
 * @generated from message flowstate.v1.GetDataCommand
 */
export class GetDataCommand extends Message<GetDataCommand> {
  /**
   * @generated from field: flowstate.v1.StateCtxRef state_ref = 1;
   */
  stateRef?: StateCtxRef;

  /**
   * @generated from field: string alias = 2;
   */
  alias = "";

  constructor(data?: PartialMessage<GetDataCommand>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flowstate.v1.GetDataCommand";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "state_ref", kind: "message", T: StateCtxRef },
    { no: 2, name: "alias", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetDataCommand {
    return new GetDataCommand().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetDataCommand {
    return new GetDataCommand().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetDataCommand {
    return new GetDataCommand().fromJsonString(jsonString, options);
  }

  static equals(a: GetDataCommand | PlainMessage<GetDataCommand> | undefined, b: GetDataCommand | PlainMessage<GetDataCommand> | undefined): boolean {
    return proto3.util.equals(GetDataCommand, a, b);
  }
}

/**
 * @generated from message flowstate.v1.GetStateByIDCommand
 */
export class GetStateByIDCommand extends Message<GetStateByIDCommand> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: int64 rev = 2;
   */
  rev = protoInt64.zero;

  /**
   * @generated from field: flowstate.v1.StateCtxRef state_ref = 3;
   */
  stateRef?: StateCtxRef;

  constructor(data?: PartialMessage<GetStateByIDCommand>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flowstate.v1.GetStateByIDCommand";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "rev", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "state_ref", kind: "message", T: StateCtxRef },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetStateByIDCommand {
    return new GetStateByIDCommand().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetStateByIDCommand {
    return new GetStateByIDCommand().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetStateByIDCommand {
    return new GetStateByIDCommand().fromJsonString(jsonString, options);
  }

  static equals(a: GetStateByIDCommand | PlainMessage<GetStateByIDCommand> | undefined, b: GetStateByIDCommand | PlainMessage<GetStateByIDCommand> | undefined): boolean {
    return proto3.util.equals(GetStateByIDCommand, a, b);
  }
}

/**
 * @generated from message flowstate.v1.GetStateByLabelsCommand
 */
export class GetStateByLabelsCommand extends Message<GetStateByLabelsCommand> {
  /**
   * @generated from field: map<string, string> labels = 1;
   */
  labels: { [key: string]: string } = {};

  /**
   * @generated from field: flowstate.v1.StateCtxRef state_ref = 2;
   */
  stateRef?: StateCtxRef;

  constructor(data?: PartialMessage<GetStateByLabelsCommand>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flowstate.v1.GetStateByLabelsCommand";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "labels", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 2, name: "state_ref", kind: "message", T: StateCtxRef },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetStateByLabelsCommand {
    return new GetStateByLabelsCommand().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetStateByLabelsCommand {
    return new GetStateByLabelsCommand().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetStateByLabelsCommand {
    return new GetStateByLabelsCommand().fromJsonString(jsonString, options);
  }

  static equals(a: GetStateByLabelsCommand | PlainMessage<GetStateByLabelsCommand> | undefined, b: GetStateByLabelsCommand | PlainMessage<GetStateByLabelsCommand> | undefined): boolean {
    return proto3.util.equals(GetStateByLabelsCommand, a, b);
  }
}

/**
 * @generated from message flowstate.v1.GetStatesCommand
 */
export class GetStatesCommand extends Message<GetStatesCommand> {
  /**
   * @generated from field: int64 since_rev = 1;
   */
  sinceRev = protoInt64.zero;

  /**
   * @generated from field: int64 since_time_usec = 2;
   */
  sinceTimeUsec = protoInt64.zero;

  /**
   * @generated from field: repeated flowstate.v1.GetStatesCommand.Labels labels = 3;
   */
  labels: GetStatesCommand_Labels[] = [];

  /**
   * @generated from field: bool latest_only = 4;
   */
  latestOnly = false;

  /**
   * @generated from field: int64 limit = 5;
   */
  limit = protoInt64.zero;

  /**
   * @generated from field: flowstate.v1.GetStatesResult result = 6;
   */
  result?: GetStatesResult;

  constructor(data?: PartialMessage<GetStatesCommand>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flowstate.v1.GetStatesCommand";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "since_rev", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "since_time_usec", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "labels", kind: "message", T: GetStatesCommand_Labels, repeated: true },
    { no: 4, name: "latest_only", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "limit", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 6, name: "result", kind: "message", T: GetStatesResult },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetStatesCommand {
    return new GetStatesCommand().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetStatesCommand {
    return new GetStatesCommand().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetStatesCommand {
    return new GetStatesCommand().fromJsonString(jsonString, options);
  }

  static equals(a: GetStatesCommand | PlainMessage<GetStatesCommand> | undefined, b: GetStatesCommand | PlainMessage<GetStatesCommand> | undefined): boolean {
    return proto3.util.equals(GetStatesCommand, a, b);
  }
}

/**
 * @generated from message flowstate.v1.GetStatesCommand.Labels
 */
export class GetStatesCommand_Labels extends Message<GetStatesCommand_Labels> {
  /**
   * @generated from field: map<string, string> labels = 1;
   */
  labels: { [key: string]: string } = {};

  constructor(data?: PartialMessage<GetStatesCommand_Labels>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flowstate.v1.GetStatesCommand.Labels";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "labels", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetStatesCommand_Labels {
    return new GetStatesCommand_Labels().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetStatesCommand_Labels {
    return new GetStatesCommand_Labels().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetStatesCommand_Labels {
    return new GetStatesCommand_Labels().fromJsonString(jsonString, options);
  }

  static equals(a: GetStatesCommand_Labels | PlainMessage<GetStatesCommand_Labels> | undefined, b: GetStatesCommand_Labels | PlainMessage<GetStatesCommand_Labels> | undefined): boolean {
    return proto3.util.equals(GetStatesCommand_Labels, a, b);
  }
}

/**
 * @generated from message flowstate.v1.GetStatesResult
 */
export class GetStatesResult extends Message<GetStatesResult> {
  /**
   * @generated from field: repeated flowstate.v1.State states = 1;
   */
  states: State[] = [];

  /**
   * @generated from field: bool more = 2;
   */
  more = false;

  constructor(data?: PartialMessage<GetStatesResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flowstate.v1.GetStatesResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "states", kind: "message", T: State, repeated: true },
    { no: 2, name: "more", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetStatesResult {
    return new GetStatesResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetStatesResult {
    return new GetStatesResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetStatesResult {
    return new GetStatesResult().fromJsonString(jsonString, options);
  }

  static equals(a: GetStatesResult | PlainMessage<GetStatesResult> | undefined, b: GetStatesResult | PlainMessage<GetStatesResult> | undefined): boolean {
    return proto3.util.equals(GetStatesResult, a, b);
  }
}

/**
 * @generated from message flowstate.v1.GetDelayedStatesCommand
 */
export class GetDelayedStatesCommand extends Message<GetDelayedStatesCommand> {
  /**
   * @generated from field: int64 since_time_sec = 1;
   */
  sinceTimeSec = protoInt64.zero;

  /**
   * @generated from field: int64 until_time_sec = 2;
   */
  untilTimeSec = protoInt64.zero;

  /**
   * @generated from field: int64 offset = 3;
   */
  offset = protoInt64.zero;

  /**
   * @generated from field: int64 limit = 4;
   */
  limit = protoInt64.zero;

  /**
   * @generated from field: flowstate.v1.GetDelayedStatesResult result = 5;
   */
  result?: GetDelayedStatesResult;

  constructor(data?: PartialMessage<GetDelayedStatesCommand>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flowstate.v1.GetDelayedStatesCommand";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "since_time_sec", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "until_time_sec", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "offset", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "limit", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 5, name: "result", kind: "message", T: GetDelayedStatesResult },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetDelayedStatesCommand {
    return new GetDelayedStatesCommand().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetDelayedStatesCommand {
    return new GetDelayedStatesCommand().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetDelayedStatesCommand {
    return new GetDelayedStatesCommand().fromJsonString(jsonString, options);
  }

  static equals(a: GetDelayedStatesCommand | PlainMessage<GetDelayedStatesCommand> | undefined, b: GetDelayedStatesCommand | PlainMessage<GetDelayedStatesCommand> | undefined): boolean {
    return proto3.util.equals(GetDelayedStatesCommand, a, b);
  }
}

/**
 * @generated from message flowstate.v1.GetDelayedStatesResult
 */
export class GetDelayedStatesResult extends Message<GetDelayedStatesResult> {
  /**
   * @generated from field: repeated flowstate.v1.DelayedState delayed_states = 1;
   */
  delayedStates: DelayedState[] = [];

  /**
   * @generated from field: bool more = 2;
   */
  more = false;

  constructor(data?: PartialMessage<GetDelayedStatesResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flowstate.v1.GetDelayedStatesResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "delayed_states", kind: "message", T: DelayedState, repeated: true },
    { no: 2, name: "more", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetDelayedStatesResult {
    return new GetDelayedStatesResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetDelayedStatesResult {
    return new GetDelayedStatesResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetDelayedStatesResult {
    return new GetDelayedStatesResult().fromJsonString(jsonString, options);
  }

  static equals(a: GetDelayedStatesResult | PlainMessage<GetDelayedStatesResult> | undefined, b: GetDelayedStatesResult | PlainMessage<GetDelayedStatesResult> | undefined): boolean {
    return proto3.util.equals(GetDelayedStatesResult, a, b);
  }
}

